From b1d1e8d767e8ef0e1b815a5ad9a7f1c2287837aa Mon Sep 17 00:00:00 2001
From: Daniel Danzberger <daniel@dd-wrt.com>
Date: Tue, 28 Sep 2021 14:10:54 +0200
Subject: [PATCH 3/4] Add firewall abstraction layer

This commit adds a firewall abstraction layer, which allows other
firewalls than iptables to be implemented and selected via build option.

Firewall API functions have therefore been renamed from
'iptables_fw_*' to 'fw_*'.

Iptables specific code has been moved from the header to fw_iptables.c

Signed-off-by: Daniel Danzberger <daniel@dd-wrt.com>
---
 src/auth.c                  |  28 ++---
 src/client_list.c           |   2 +-
 src/{fw_iptables.h => fw.h} |  55 ++++------
 src/fw_iptables.c           | 206 +++++++++++++++++++-----------------
 src/http_microhttpd.c       |   2 +-
 src/main.c                  |  12 +--
 src/ndsctl.c                |   2 +-
 src/ndsctl_thread.c         |   2 +-
 src/util.c                  |  13 +--
 9 files changed, 159 insertions(+), 163 deletions(-)
 rename src/{fw_iptables.h => fw.h} (66%)

diff --git a/src/auth.c b/src/auth.c
index 4e358dd..f917a03 100644
--- a/src/auth.c
+++ b/src/auth.c
@@ -40,7 +40,7 @@
 #include "conf.h"
 #include "debug.h"
 #include "auth.h"
-#include "fw_iptables.h"
+#include "fw.h"
 #include "client_list.h"
 #include "util.h"
 #include "http_microhttpd_utils.h"
@@ -138,7 +138,7 @@ static int auth_change_state(t_client *client, const unsigned int new_state, con
 		return -1;
 	} else if (state == FW_MARK_PREAUTHENTICATED) {
 		if (new_state == FW_MARK_AUTHENTICATED) {
-			iptables_fw_authenticate(client);
+			fw_authenticate(client);
 
 			if (client->upload_rate == 0) {
 				client->upload_rate = config->upload_rate;
@@ -176,7 +176,7 @@ static int auth_change_state(t_client *client, const unsigned int new_state, con
 		}
 	} else if (state == FW_MARK_AUTHENTICATED) {
 		if (new_state == FW_MARK_PREAUTHENTICATED) {
-			iptables_fw_deauthenticate(client);
+			fw_deauthenticate(client);
 			binauth_action(client, reason, customdata);
 			client_reset(client);
 		} else if (new_state == FW_MARK_BLOCKED) {
@@ -263,7 +263,7 @@ fw_refresh_client_list(void)
 	debug(LOG_DEBUG, "Rate Check Window is set to %u period(s) of checkinterval", config->rate_check_window);
 
 	// Update all the counters
-	if (-1 == iptables_fw_counters_update()) {
+	if (-1 == fw_counters_update()) {
 		debug(LOG_ERR, "Could not get counters from firewall!");
 		return;
 	}
@@ -430,7 +430,7 @@ fw_refresh_client_list(void)
 							uprate
 						);
 						action = ENABLE;
-						iptables_download_ratelimit_enable(cp1, action);
+						fw_download_ratelimit_enable(cp1, action);
 						//bit 0 is not set so toggle it to signify rate limiting is on
 						cp1->rate_exceeded = cp1->rate_exceeded^1;
 					}
@@ -446,7 +446,7 @@ fw_refresh_client_list(void)
 						);
 
 						action = DISABLE;
-						iptables_download_ratelimit_enable(cp1, action);
+						fw_download_ratelimit_enable(cp1, action);
 						//bit 0 is set so toggle it to signify rate limiting is off
 						cp1->rate_exceeded = cp1->rate_exceeded^1;
 					}
@@ -477,7 +477,7 @@ fw_refresh_client_list(void)
 						);
 
 						action = ENABLE;
-						iptables_upload_ratelimit_enable(cp1, action);
+						fw_upload_ratelimit_enable(cp1, action);
 						//bit 1 is not set so toggle it to signify rate limiting is on
 						cp1->rate_exceeded = cp1->rate_exceeded^2;
 					}
@@ -494,7 +494,7 @@ fw_refresh_client_list(void)
 						);
 
 						action = DISABLE;
-						iptables_upload_ratelimit_enable(cp1, action);
+						fw_upload_ratelimit_enable(cp1, action);
 						//bit 1 is set so toggle it to signify rate limiting is off
 						cp1->rate_exceeded = cp1->rate_exceeded^2;
 					}
@@ -657,7 +657,7 @@ auth_client_trust(const char *mac)
 
 	LOCK_CONFIG();
 
-	if (!add_to_trusted_mac_list(mac) && !iptables_trust_mac(mac)) {
+	if (!add_to_trusted_mac_list(mac) && !fw_trust_mac(mac)) {
 		rc = 0;
 	}
 
@@ -673,7 +673,7 @@ auth_client_untrust(const char *mac)
 
 	LOCK_CONFIG();
 
-	if (!remove_from_trusted_mac_list(mac) && !iptables_untrust_mac(mac)) {
+	if (!remove_from_trusted_mac_list(mac) && !fw_untrust_mac(mac)) {
 		rc = 0;
 	}
 
@@ -688,7 +688,7 @@ auth_client_allow(const char *mac)
 
 	LOCK_CONFIG();
 
-	if (!add_to_allowed_mac_list(mac) && !iptables_allow_mac(mac)) {
+	if (!add_to_allowed_mac_list(mac) && !fw_allow_mac(mac)) {
 		rc = 0;
 	}
 
@@ -704,7 +704,7 @@ auth_client_unallow(const char *mac)
 
 	LOCK_CONFIG();
 
-	if (!remove_from_allowed_mac_list(mac) && !iptables_unallow_mac(mac)) {
+	if (!remove_from_allowed_mac_list(mac) && !fw_unallow_mac(mac)) {
 		rc = 0;
 	}
 
@@ -720,7 +720,7 @@ auth_client_block(const char *mac)
 
 	LOCK_CONFIG();
 
-	if (!add_to_blocked_mac_list(mac) && !iptables_block_mac(mac)) {
+	if (!add_to_blocked_mac_list(mac) && !fw_block_mac(mac)) {
 		rc = 0;
 	}
 
@@ -736,7 +736,7 @@ auth_client_unblock(const char *mac)
 
 	LOCK_CONFIG();
 
-	if (!remove_from_blocked_mac_list(mac) && !iptables_unblock_mac(mac)) {
+	if (!remove_from_blocked_mac_list(mac) && !fw_unblock_mac(mac)) {
 		rc = 0;
 	}
 
diff --git a/src/client_list.c b/src/client_list.c
index 64ebef1..dd0e75f 100644
--- a/src/client_list.c
+++ b/src/client_list.c
@@ -41,7 +41,7 @@
 #include "conf.h"
 #include "client_list.h"
 #include "http_microhttpd.h"
-#include "fw_iptables.h"
+#include "fw.h"
 #include "util.h"
 
 
diff --git a/src/fw_iptables.h b/src/fw.h
similarity index 66%
rename from src/fw_iptables.h
rename to src/fw.h
index b62b746..f98aed5 100644
--- a/src/fw_iptables.h
+++ b/src/fw.h
@@ -24,28 +24,12 @@
     @author Copyright (C) 2007 Paul Kube <nodogsplash@kokoro.ucsd.edu>
 */
 
-#ifndef _FW_IPTABLES_H_
-#define _FW_IPTABLES_H_
+#ifndef _FW_H_
+#define _FW_H_
 
 #include "auth.h"
 #include "client_list.h"
 
-/*@{*/
-/**Iptable chain names used by opennds */
-#define CHAIN_TO_INTERNET "ndsNET"
-#define CHAIN_TO_ROUTER "ndsRTR"
-#define CHAIN_TRUSTED_TO_ROUTER "ndsTRT"
-#define CHAIN_OUTGOING  "ndsOUT"
-#define CHAIN_INCOMING  "ndsINC"
-#define CHAIN_UPLOAD_RATE  "ndsULR"
-#define CHAIN_AUTHENTICATED     "ndsAUT"
-#define CHAIN_PREAUTHENTICATED   "ndsPRE"
-#define CHAIN_BLOCKED    "ndsBLK"
-#define CHAIN_ALLOWED    "ndsALW"
-#define CHAIN_TRUSTED    "ndsTRU"
-/*@}*/
-
-
 /** Used to mark packets, and characterize client state.  Unmarked packets are considered 'preauthenticated' */
 extern unsigned int  FW_MARK_PREAUTHENTICATED; /**< @brief 0: Actually not used as a packet mark */
 extern unsigned int  FW_MARK_AUTHENTICATED;    /**< @brief The client is authenticated */
@@ -55,46 +39,45 @@ extern unsigned int  FW_MARK_MASK;             /**< @brief Iptables mask: bitwis
 
 
 /** @brief Initialize the firewall */
-int iptables_fw_init(void);
+int fw_init(void);
 
 /** @brief Destroy the firewall */
-int iptables_fw_destroy(void);
+int fw_destroy(void);
 
-/** @brief Helper function for iptables_fw_destroy */
-int iptables_fw_destroy_mention( const char table[], const char chain[], const char mention[]);
+/** @brief Helper function for fw_destroy */
+int fw_destroy_mention( const char table[], const char chain[], const char mention[]);
 
 /** @brief Define the access of a specific client */
-int iptables_fw_authenticate(t_client *client);
-int iptables_fw_deauthenticate(t_client *client);
+int fw_authenticate(t_client *client);
+int fw_deauthenticate(t_client *client);
 
 /** @brief Enable/Disable Upload Rate Limiting of a specific client */
-int iptables_upload_ratelimit_enable(t_client *client, int enable);
+int fw_upload_ratelimit_enable(t_client *client, int enable);
 
 /** @brief Enable/Disable Download Rate Limiting of a specific client */
-int iptables_download_ratelimit_enable(t_client *client, int enable);
+int fw_download_ratelimit_enable(t_client *client, int enable);
 
 /** @brief Return the total download usage in bytes */
-unsigned long long int iptables_fw_total_download();
+unsigned long long int fw_total_download();
 
 /** @brief Return the total upload usage in bytes */
-unsigned long long int iptables_fw_total_upload();
+unsigned long long int fw_total_upload();
 
 /** @brief All counters in the client list */
-int iptables_fw_counters_update(void);
+int fw_counters_update(void);
 
 /** @brief Return a string representing a connection state */
 const char *fw_connection_state_as_string(int mark);
 
 /** @brief Fork an iptables command */
-int iptables_do_command(const char format[], ...);
 
-int iptables_block_mac(const char mac[]);
-int iptables_unblock_mac(const char mac[]);
+int fw_block_mac(const char mac[]);
+int fw_unblock_mac(const char mac[]);
 
-int iptables_allow_mac(const char mac[]);
-int iptables_unallow_mac(const char mac[]);
+int fw_allow_mac(const char mac[]);
+int fw_unallow_mac(const char mac[]);
 
-int iptables_trust_mac(const char mac[]);
-int iptables_untrust_mac(const char mac[]);
+int fw_trust_mac(const char mac[]);
+int fw_untrust_mac(const char mac[]);
 
 #endif /* _IPTABLES_H_ */
diff --git a/src/fw_iptables.c b/src/fw_iptables.c
index cfa291e..fbd9aa1 100644
--- a/src/fw_iptables.c
+++ b/src/fw_iptables.c
@@ -44,16 +44,28 @@
 #include "conf.h"
 #include "auth.h"
 #include "client_list.h"
-#include "fw_iptables.h"
+#include "fw.h"
 #include "debug.h"
 #include "util.h"
 
 // iptables v1.4.17
 #define MIN_IPTABLES_VERSION (1 * 10000 + 4 * 100 + 17)
 
-static char *_iptables_compile(const char[], const char[], t_firewall_rule *);
-static int _iptables_append_ruleset(const char[], const char[], const char[]);
-static int _iptables_init_marks(void);
+/*@{*/
+/**Iptable chain names used by opennds */
+#define CHAIN_TO_INTERNET "ndsNET"
+#define CHAIN_TO_ROUTER "ndsRTR"
+#define CHAIN_TRUSTED_TO_ROUTER "ndsTRT"
+#define CHAIN_OUTGOING  "ndsOUT"
+#define CHAIN_INCOMING  "ndsINC"
+#define CHAIN_UPLOAD_RATE  "ndsULR"
+#define CHAIN_AUTHENTICATED     "ndsAUT"
+#define CHAIN_PREAUTHENTICATED   "ndsPRE"
+#define CHAIN_BLOCKED    "ndsBLK"
+#define CHAIN_ALLOWED    "ndsALW"
+#define CHAIN_TRUSTED    "ndsTRU"
+/*@}*/
+
 
 // Used to mark packets, and characterize client state.  Unmarked packets are considered 'preauthenticated'
 unsigned int FW_MARK_PREAUTHENTICATED; // @brief 0: Actually not used as a packet mark
@@ -74,6 +86,47 @@ static const char* markop = "--set-mark";
 // Used to configure use of mark mask, or not
 static const char* markmask = "";
 
+// @internal
+static int
+iptables_do_command(const char *format, ...)
+{
+	va_list vlist;
+	char *fmt_cmd = NULL;
+	s_config *config;
+	char *iptables;
+	int rc;
+	int i;
+
+	va_start(vlist, format);
+	safe_vasprintf(&fmt_cmd, format, vlist);
+	va_end(vlist);
+
+	config = config_get_config();
+
+	iptables = config->ip6 ? "ip6tables" : "iptables";
+
+	for (i = 0; i < 5; i++) {
+		if (fw_quiet) {
+			rc = execute("%s --wait %s > /dev/null 2>&1", iptables, fmt_cmd);
+		} else {
+			rc = execute("%s --wait %s", iptables, fmt_cmd);
+		}
+
+		if (rc == 4) {
+			/* iptables error code 4 indicates a resource problem that might
+			 * be temporary. So we retry to insert the rule a few times. (Mitar) */
+			sleep(1);
+		} else {
+			break;
+		}
+	}
+
+	debug(LOG_DEBUG,"iptables command [ %s ], return code [ %d ]", fmt_cmd, rc);
+	free(fmt_cmd);
+
+	return rc;
+}
+
 // Return a string representing a connection state
 const char *
 fw_connection_state_as_string(int mark)
@@ -90,8 +143,8 @@ fw_connection_state_as_string(int mark)
 }
 
 // @internal
-int
-_iptables_init_marks()
+static int
+_fw_init_marks()
 {
 	// Check FW_MARK values are distinct.
 	if (FW_MARK_BLOCKED == FW_MARK_TRUSTED ||
@@ -130,8 +183,8 @@ _iptables_init_marks()
 }
 
 // @internal
-int
-_iptables_check_mark_masking()
+static int
+_fw_check_mark_masking()
 {
 	// See if kernel supports mark or-ing
 	fw_quiet = 1; // do it quietly
@@ -163,47 +216,6 @@ _iptables_check_mark_masking()
 	return 0;
 }
 
-// @internal
-int
-iptables_do_command(const char *format, ...)
-{
-	va_list vlist;
-	char *fmt_cmd = NULL;
-	s_config *config;
-	char *iptables;
-	int rc;
-	int i;
-
-	va_start(vlist, format);
-	safe_vasprintf(&fmt_cmd, format, vlist);
-	va_end(vlist);
-
-	config = config_get_config();
-
-	iptables = config->ip6 ? "ip6tables" : "iptables";
-
-	for (i = 0; i < 5; i++) {
-		if (fw_quiet) {
-			rc = execute("%s --wait %s > /dev/null 2>&1", iptables, fmt_cmd);
-		} else {
-			rc = execute("%s --wait %s", iptables, fmt_cmd);
-		}
-
-		if (rc == 4) {
-			/* iptables error code 4 indicates a resource problem that might
-			 * be temporary. So we retry to insert the rule a few times. (Mitar) */
-			sleep(1);
-		} else {
-			break;
-		}
-	}
-
-	debug(LOG_DEBUG,"iptables command [ %s ], return code [ %d ]", fmt_cmd, rc);
-	free(fmt_cmd);
-
-	return rc;
-}
-
 /**
  * @internal
  * Compiles a struct definition of a firewall rule into a valid iptables
@@ -213,7 +225,7 @@ iptables_do_command(const char *format, ...)
  * @arg rule Definition of a rule into a struct, from conf.c.
  */
 static char *
-_iptables_compile(const char table[], const char chain[], t_firewall_rule *rule)
+_fw_compile(const char table[], const char chain[], t_firewall_rule *rule)
 {
 	char command[MAX_BUF];
 	char *mode;
@@ -292,7 +304,7 @@ _iptables_compile(const char table[], const char chain[], t_firewall_rule *rule)
  * @arg chain IPTables chain the rules go into
  */
 static int
-_iptables_append_ruleset(const char table[], const char ruleset[], const char chain[])
+_fw_append_ruleset(const char table[], const char ruleset[], const char chain[])
 {
 	t_firewall_rule *rule;
 	char *cmd;
@@ -301,7 +313,7 @@ _iptables_append_ruleset(const char table[], const char ruleset[], const char ch
 	debug(LOG_DEBUG, "Loading ruleset %s into table %s, chain %s", ruleset, table, chain);
 
 	for (rule = get_ruleset_list(ruleset); rule != NULL; rule = rule->next) {
-		cmd = _iptables_compile(table, chain, rule);
+		cmd = _fw_compile(table, chain, rule);
 		debug(LOG_DEBUG, "Loading rule \"%s\" into table %s, chain %s", cmd, table, chain);
 		ret |= iptables_do_command(cmd);
 		free(cmd);
@@ -312,42 +324,42 @@ _iptables_append_ruleset(const char table[], const char ruleset[], const char ch
 }
 
 int
-iptables_block_mac(const char mac[])
+fw_block_mac(const char mac[])
 {
 	return iptables_do_command("-t mangle -A " CHAIN_BLOCKED " -m mac --mac-source %s -j MARK %s 0x%x", mac, markop, FW_MARK_BLOCKED);
 }
 
 int
-iptables_unblock_mac(const char mac[])
+fw_unblock_mac(const char mac[])
 {
 	return iptables_do_command("-t mangle -D " CHAIN_BLOCKED " -m mac --mac-source %s -j MARK %s 0x%x", mac, markop, FW_MARK_BLOCKED);
 }
 
 int
-iptables_allow_mac(const char mac[])
+fw_allow_mac(const char mac[])
 {
 	return iptables_do_command("-t mangle -I " CHAIN_BLOCKED " -m mac --mac-source %s -j RETURN", mac);
 }
 
 int
-iptables_unallow_mac(const char mac[])
+fw_unallow_mac(const char mac[])
 {
 	return iptables_do_command("-t mangle -D " CHAIN_BLOCKED " -m mac --mac-source %s -j RETURN", mac);
 }
 
 int
-iptables_trust_mac(const char mac[])
+fw_trust_mac(const char mac[])
 {
 	return iptables_do_command("-t mangle -A " CHAIN_TRUSTED " -m mac --mac-source %s -j MARK %s 0x%x", mac, markop, FW_MARK_TRUSTED);
 }
 
 int
-iptables_untrust_mac(const char mac[])
+fw_untrust_mac(const char mac[])
 {
 	return iptables_do_command("-t mangle -D " CHAIN_TRUSTED " -m mac --mac-source %s -j MARK %s 0x%x", mac, markop, FW_MARK_TRUSTED);
 }
 
-int get_iptables_version()
+int get_fw_version()
 {
 	char buf[256];
 	int minor;
@@ -366,10 +378,10 @@ int get_iptables_version()
 
 // Initialize the firewall rules.
 int
-iptables_fw_init(void)
+fw_init(void)
 {
 	s_config *config;
-	int iptables_version;
+	int fw_version;
 	char *gw_interface = NULL;
 	char *gw_ip = NULL;
 	char *gw_address = NULL;
@@ -421,17 +433,17 @@ iptables_fw_init(void)
 	FW_MARK_AUTHENTICATED = config->fw_mark_authenticated;
 	UNLOCK_CONFIG();
 
-	iptables_version = get_iptables_version();
-	if (iptables_version < 0) {
+	fw_version = get_fw_version();
+	if (fw_version < 0) {
 		debug(LOG_ERR, "Cannot get iptables version.");
 		return -1;
 	}
 
-	if (iptables_version < MIN_IPTABLES_VERSION) {
+	if (fw_version < MIN_IPTABLES_VERSION) {
 		debug(LOG_ERR, "Unsupported iptables version v%d.%d.%d, needs at least v%d.%d.%d.",
-			(iptables_version / 10000),
-			(iptables_version % 10000) / 100,
-			(iptables_version % 100),
+			(fw_version / 10000),
+			(fw_version % 10000) / 100,
+			(fw_version % 100),
 			(MIN_IPTABLES_VERSION / 10000),
 			(MIN_IPTABLES_VERSION % 10000) / 100,
 			(MIN_IPTABLES_VERSION % 100)
@@ -440,8 +452,8 @@ iptables_fw_init(void)
 	}
 
 	// Set up packet marking methods
-	rc |= _iptables_init_marks();
-	rc |= _iptables_check_mark_masking();
+	rc |= _fw_init_marks();
+	rc |= _fw_check_mark_masking();
 
 	/*
 	 *
@@ -465,7 +477,7 @@ iptables_fw_init(void)
 
 	// Rules to mark as trusted MAC address packets in mangle PREROUTING
 	for (; pt != NULL; pt = pt->next) {
-		rc |= iptables_trust_mac(pt->mac);
+		rc |= fw_trust_mac(pt->mac);
 	}
 
 	// Rules to mark as blocked MAC address packets in mangle PREROUTING
@@ -474,7 +486,7 @@ iptables_fw_init(void)
 		 * MAC's on the block list are marked as blocked;
 		 * everything else passes */
 		for (; pb != NULL; pb = pb->next) {
-			rc |= iptables_block_mac(pb->mac);
+			rc |= fw_block_mac(pb->mac);
 		}
 	} else if (MAC_ALLOW == macmechanism) {
 		/* with the MAC_ALLOW mechanism,
@@ -485,7 +497,7 @@ iptables_fw_init(void)
 		rc |= iptables_do_command("-t mangle -A " CHAIN_BLOCKED " -j MARK %s 0x%x", markop, FW_MARK_BLOCKED);
 		// But insert at beginning of chain rules to pass allowed MAC's
 		for (; pa != NULL; pa = pa->next) {
-			rc |= iptables_allow_mac(pa->mac);
+			rc |= fw_allow_mac(pa->mac);
 		}
 	} else {
 		debug(LOG_ERR, "Unknown MAC mechanism: %d", macmechanism);
@@ -593,7 +605,7 @@ iptables_fw_init(void)
 		// CHAIN_TRUSTED_TO_ROUTER, related and established packets ACCEPT
 		rc |= iptables_do_command("-t filter -A " CHAIN_TRUSTED_TO_ROUTER " -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT");
 		// CHAIN_TRUSTED_TO_ROUTER, append the "trusted-users-to-router" ruleset
-		rc |= _iptables_append_ruleset("filter", "trusted-users-to-router", CHAIN_TRUSTED_TO_ROUTER);
+		rc |= _fw_append_ruleset("filter", "trusted-users-to-router", CHAIN_TRUSTED_TO_ROUTER);
 		// CHAIN_TRUSTED_TO_ROUTER, any packets not matching that ruleset REJECT
 		rc |= iptables_do_command("-t filter -A " CHAIN_TRUSTED_TO_ROUTER " -j REJECT --reject-with %s-port-unreachable", ICMP_TYPE);
 	}
@@ -609,7 +621,7 @@ iptables_fw_init(void)
 		rc |= iptables_do_command("-t filter -A " CHAIN_TO_ROUTER " -j %s", get_empty_ruleset_policy("users-to-router"));
 	} else {
 		// CHAIN_TO_ROUTER, append the "users-to-router" ruleset
-		rc |= _iptables_append_ruleset("filter", "users-to-router", CHAIN_TO_ROUTER);
+		rc |= _fw_append_ruleset("filter", "users-to-router", CHAIN_TO_ROUTER);
 
 		// CHAIN_TO_ROUTER packets marked AUTHENTICATED RETURN
 		rc |= iptables_do_command("-t filter -A " CHAIN_TO_ROUTER " -m mark --mark 0x%x%s -j RETURN", FW_MARK_AUTHENTICATED, markmask);
@@ -694,7 +706,7 @@ iptables_fw_init(void)
 		// CHAIN_TRUSTED, related and established packets ACCEPT
 		rc |= iptables_do_command("-t filter -A " CHAIN_TRUSTED " -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT");
 		// CHAIN_TRUSTED, append the "trusted-users" ruleset
-		rc |= _iptables_append_ruleset("filter", "trusted-users", CHAIN_TRUSTED);
+		rc |= _fw_append_ruleset("filter", "trusted-users", CHAIN_TRUSTED);
 		// CHAIN_TRUSTED, any packets not matching that ruleset REJECT
 		rc |= iptables_do_command("-t filter -A " CHAIN_TRUSTED " -j REJECT --reject-with %s-port-unreachable", ICMP_TYPE);
 	}
@@ -725,7 +737,7 @@ iptables_fw_init(void)
 		// CHAIN_AUTHENTICATED, related and established packets ACCEPT
 		rc |= iptables_do_command("-t filter -A " CHAIN_AUTHENTICATED " -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT");
 		// CHAIN_AUTHENTICATED, append the "authenticated-users" ruleset
-		rc |= _iptables_append_ruleset("filter", "authenticated-users", CHAIN_AUTHENTICATED);
+		rc |= _fw_append_ruleset("filter", "authenticated-users", CHAIN_AUTHENTICATED);
 		// CHAIN_AUTHENTICATED, any packets not matching that ruleset REJECT
 		rc |= iptables_do_command("-t filter -A " CHAIN_AUTHENTICATED " -j REJECT --reject-with %s-port-unreachable", ICMP_TYPE);
 	}
@@ -741,7 +753,7 @@ iptables_fw_init(void)
 	if (is_empty_ruleset("preauthenticated-users")) {
 		rc |= iptables_do_command("-t filter -A " CHAIN_TO_INTERNET " -j %s ", get_empty_ruleset_policy("preauthenticated-users"));
 	} else {
-		rc |= _iptables_append_ruleset("filter", "preauthenticated-users", CHAIN_TO_INTERNET);
+		rc |= _fw_append_ruleset("filter", "preauthenticated-users", CHAIN_TO_INTERNET);
 	}
 
 	// CHAIN_TO_INTERNET, all other packets REJECT
@@ -766,7 +778,7 @@ iptables_fw_init(void)
  * and when it starts, to make sure there are no rules left over from a crash
  */
 int
-iptables_fw_destroy(void)
+fw_destroy(void)
 {
 	fw_quiet = 1;
 	s_config *config;
@@ -779,11 +791,11 @@ iptables_fw_destroy(void)
 
 	// Everything in the mangle table
 	debug(LOG_DEBUG, "Destroying chains in the MANGLE table");
-	iptables_fw_destroy_mention("mangle", "PREROUTING", CHAIN_TRUSTED);
-	iptables_fw_destroy_mention("mangle", "PREROUTING", CHAIN_BLOCKED);
-	iptables_fw_destroy_mention("mangle", "PREROUTING", CHAIN_ALLOWED);
-	iptables_fw_destroy_mention("mangle", "PREROUTING", CHAIN_OUTGOING);
-	iptables_fw_destroy_mention("mangle", "POSTROUTING", CHAIN_INCOMING);
+	fw_destroy_mention("mangle", "PREROUTING", CHAIN_TRUSTED);
+	fw_destroy_mention("mangle", "PREROUTING", CHAIN_BLOCKED);
+	fw_destroy_mention("mangle", "PREROUTING", CHAIN_ALLOWED);
+	fw_destroy_mention("mangle", "PREROUTING", CHAIN_OUTGOING);
+	fw_destroy_mention("mangle", "POSTROUTING", CHAIN_INCOMING);
 	iptables_do_command("-t mangle -F " CHAIN_TRUSTED);
 	iptables_do_command("-t mangle -F " CHAIN_BLOCKED);
 	iptables_do_command("-t mangle -F " CHAIN_ALLOWED);
@@ -798,7 +810,7 @@ iptables_fw_destroy(void)
 	// Everything in the nat table (ip4 only)
 	if (!config->ip6) {
 		debug(LOG_DEBUG, "Destroying chains in the NAT table");
-		iptables_fw_destroy_mention("nat", "PREROUTING", CHAIN_OUTGOING);
+		fw_destroy_mention("nat", "PREROUTING", CHAIN_OUTGOING);
 		iptables_do_command("-t nat -F " CHAIN_OUTGOING);
 		iptables_do_command("-t nat -X " CHAIN_OUTGOING);
 	}
@@ -806,8 +818,8 @@ iptables_fw_destroy(void)
 	// Everything in the filter table
 
 	debug(LOG_DEBUG, "Destroying chains in the FILTER table");
-	iptables_fw_destroy_mention("filter", "INPUT", CHAIN_TO_ROUTER);
-	iptables_fw_destroy_mention("filter", "FORWARD", CHAIN_TO_INTERNET);
+	fw_destroy_mention("filter", "INPUT", CHAIN_TO_ROUTER);
+	fw_destroy_mention("filter", "FORWARD", CHAIN_TO_INTERNET);
 	iptables_do_command("-t filter -F " CHAIN_TO_ROUTER);
 	iptables_do_command("-t filter -F " CHAIN_TO_INTERNET);
 	iptables_do_command("-t filter -F " CHAIN_AUTHENTICATED);
@@ -827,13 +839,13 @@ iptables_fw_destroy(void)
 }
 
 /*
- * Helper for iptables_fw_destroy
+ * Helper for fw_destroy
  * @param table The table to search
  * @param chain The chain in that table to search
  * @param mention A word to find and delete in rules in the given table+chain
  */
 int
-iptables_fw_destroy_mention(
+fw_destroy_mention(
 	const char *table,
 	const char *chain,
 	const char *mention
@@ -882,7 +894,7 @@ iptables_fw_destroy_mention(
 
 	if (retval == 0) {
 		// Recurse just in case there are more in the same table+chain
-		iptables_fw_destroy_mention(table, chain, mention);
+		fw_destroy_mention(table, chain, mention);
 	}
 
 	return (retval);
@@ -890,7 +902,7 @@ iptables_fw_destroy_mention(
 
 // Enable/Disable Download Rate Limiting for client
 int
-iptables_download_ratelimit_enable(t_client *client, int enable)
+fw_download_ratelimit_enable(t_client *client, int enable)
 {
 	int rc = 0;
 	unsigned long long int packets;
@@ -947,7 +959,7 @@ iptables_download_ratelimit_enable(t_client *client, int enable)
 
 // Enable/Disable Upload Rate Limiting for client
 int
-iptables_upload_ratelimit_enable(t_client *client, int enable)
+fw_upload_ratelimit_enable(t_client *client, int enable)
 {
 	int rc = 0;
 	unsigned long long int packets;
@@ -981,7 +993,7 @@ iptables_upload_ratelimit_enable(t_client *client, int enable)
 
 // Insert or delete firewall mangle rules marking a client's packets.
 int
-iptables_fw_authenticate(t_client *client)
+fw_authenticate(t_client *client)
 {
 	int rc = 0;
 
@@ -995,7 +1007,7 @@ iptables_fw_authenticate(t_client *client)
 		FW_MARK_AUTHENTICATED
 	);
 
-	// This rule is just for download (incoming) byte counting, see iptables_fw_counters_update()
+	// This rule is just for download (incoming) byte counting, see fw_counters_update()
 	rc |= iptables_do_command("-t mangle -A " CHAIN_INCOMING " -d %s -j MARK %s 0x%x", client->ip, markop, FW_MARK_AUTHENTICATED);
 
 	rc |= iptables_do_command("-t mangle -A " CHAIN_INCOMING " -d %s -j ACCEPT", client->ip);
@@ -1004,7 +1016,7 @@ iptables_fw_authenticate(t_client *client)
 }
 
 int
-iptables_fw_deauthenticate(t_client *client)
+fw_deauthenticate(t_client *client)
 {
 	unsigned long long int download_rate, packetsdown;
 	int rc = 0;
@@ -1034,7 +1046,7 @@ iptables_fw_deauthenticate(t_client *client)
 
 // Return the total upload usage in bytes
 unsigned long long int
-iptables_fw_total_upload()
+fw_total_upload()
 {
 	FILE *output;
 	const char *script;
@@ -1072,7 +1084,7 @@ iptables_fw_total_upload()
 
 // Return the total download usage in bytes
 unsigned long long int
-iptables_fw_total_download()
+fw_total_download()
 {
 	FILE *output;
 	const char *script;
@@ -1110,7 +1122,7 @@ iptables_fw_total_download()
 
 // Update the counters of all the clients in the client list
 int
-iptables_fw_counters_update(void)
+fw_counters_update(void)
 {
 	FILE *output;
 	char *script;
diff --git a/src/http_microhttpd.c b/src/http_microhttpd.c
index 17149f1..c8599d6 100644
--- a/src/http_microhttpd.c
+++ b/src/http_microhttpd.c
@@ -36,7 +36,7 @@
 #include "auth.h"
 #include "http_microhttpd.h"
 #include "http_microhttpd_utils.h"
-#include "fw_iptables.h"
+#include "fw.h"
 #include "mimetypes.h"
 #include "safe.h"
 #include "util.h"
diff --git a/src/main.c b/src/main.c
index 7761c35..8ec6b0e 100644
--- a/src/main.c
+++ b/src/main.c
@@ -60,7 +60,7 @@
 #include "auth.h"
 #include "client_list.h"
 #include "ndsctl_thread.h"
-#include "fw_iptables.h"
+#include "fw.h"
 #include "util.h"
 
 #include <microhttpd.h>
@@ -142,7 +142,7 @@ termination_handler(int s)
 
 	debug(LOG_INFO, "Handler for termination caught signal %d", s);
 
-	// Makes sure we only call iptables_fw_destroy() once.
+	// Makes sure we only call fw_destroy() once.
 	if (pthread_mutex_trylock(&sigterm_mutex)) {
 		debug(LOG_INFO, "Another thread already began global termination handler. I'm exiting");
 		pthread_exit(NULL);
@@ -183,7 +183,7 @@ termination_handler(int s)
 	auth_client_deauth_all();
 
 	debug(LOG_INFO, "Flushing firewall rules...");
-	iptables_fw_destroy();
+	fw_destroy();
 
 	debug(LOG_NOTICE, "Exiting...");
 	exit(s == 0 ? 1 : 0);
@@ -286,7 +286,7 @@ setup_from_config(void)
 
 	debug(LOG_INFO, "tmpfs mountpoint is [%s]", config->tmpfsmountpoint);
 	// Before we do anything else, reset the firewall (cleans it, in case we are restarting after opennds crash)
-	iptables_fw_destroy();
+	fw_destroy();
 
 	// Check for libmicrohttp version at runtime, ie actual installed version
 	int major = 0;
@@ -793,9 +793,9 @@ setup_from_config(void)
 	}
 
 	// Now initialize the firewall
-	if (iptables_fw_init() != 0) {
+	if (fw_init() != 0) {
 		debug(LOG_ERR, "Error initializing firewall rules! Cleaning up");
-		iptables_fw_destroy();
+		fw_destroy();
 		debug(LOG_ERR, "Exiting because of error initializing firewall rules");
 		exit(1);
 	}
diff --git a/src/ndsctl.c b/src/ndsctl.c
index 507bc17..6504365 100644
--- a/src/ndsctl.c
+++ b/src/ndsctl.c
@@ -343,7 +343,7 @@ ndsctl_do(const char *socket, const struct argument *arg, const char *param)
 	} else {
 		while ((len = read(sock, buffer, sizeof(buffer) - 1)) > 0) {
 			buffer[len] = '\0';
-			printf("%s", buffer);
+			printf("%d: %s", len, buffer);
 		}
 		ret = 0;
 	}
diff --git a/src/ndsctl_thread.c b/src/ndsctl_thread.c
index ca01cc3..b7392f2 100644
--- a/src/ndsctl_thread.c
+++ b/src/ndsctl_thread.c
@@ -49,7 +49,7 @@
 #include "auth.h"
 #include "safe.h"
 #include "client_list.h"
-#include "fw_iptables.h"
+#include "fw.h"
 #include "main.h"
 
 #include "ndsctl_thread.h"
diff --git a/src/util.c b/src/util.c
index ae1c24f..6fc7b3b 100644
--- a/src/util.c
+++ b/src/util.c
@@ -68,7 +68,7 @@
 #include "util.h"
 #include "conf.h"
 #include "debug.h"
-#include "fw_iptables.h"
+#include "fw.h"
 #include "http_microhttpd_utils.h"
 
 // Defined in main.c
@@ -102,6 +102,7 @@ int check_routing(int watchdog)
 	if (execute_ret_url_encoded(rtest, sizeof(rtest) - 1, rcmd) == 0) {
 		free (rcmd);
 
+		printf("%s %s\n", rtest, rtr_fail);
 		if (strcmp(rtest, rtr_fail) == 0) {
 			debug(LOG_ERR, "Routing configuration is not valid for openNDS, exiting ...");
 			exit(1);
@@ -637,18 +638,18 @@ ndsctl_status(FILE *fp)
 	}
 
 
-	download_bytes = iptables_fw_total_download();
+	download_bytes = fw_total_download();
 	fprintf(fp, "Total download: %llu kByte", download_bytes / 1000);
 	fprintf(fp, "; avg: %.2f kbit/s\n", ((double) download_bytes) / 125 / uptimesecs);
 
-	upload_bytes = iptables_fw_total_upload();
+	upload_bytes = fw_total_upload();
 	fprintf(fp, "Total upload: %llu kByte", upload_bytes / 1000);
 	fprintf(fp, "; avg: %.2f kbit/s\n", ((double) upload_bytes) / 125 / uptimesecs);
 	fprintf(fp, "====\n");
 	fprintf(fp, "Client authentications since start: %u\n", authenticated_since_start);
 
 	// Update the client's counters so info is current
-	iptables_fw_counters_update();
+	fw_counters_update();
 
 	LOCK_CLIENT_LIST();
 
@@ -867,7 +868,7 @@ ndsctl_json_one(FILE *fp, const char *arg, char *indent)
 	now = time(NULL);
 
 	// Update the client's counters so info is current
-	iptables_fw_counters_update();
+	fw_counters_update();
 
 	LOCK_CLIENT_LIST();
 
@@ -898,7 +899,7 @@ ndsctl_json_all(FILE *fp, char *indent)
 	config = config_get_config();
 
 	// Update the client's counters so info is current
-	iptables_fw_counters_update();
+	fw_counters_update();
 
 	LOCK_CLIENT_LIST();
 
-- 
2.25.1

